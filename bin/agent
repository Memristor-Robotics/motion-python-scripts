#!/usr/bin/python3

import socket
import threading
import sys
import os
sys.path.append('/home/pi/python')
from Can import *
Can.init()
CAN_TO_NETWORK = 1
CAN_TO_SLAVES = 2

TCP_IP = '0.0.0.0'
TCP_PORT = 5005
BUFFER_SIZE = 20  # Normally 1024, but we want fast response

# bind TCP ip and port
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((TCP_IP, TCP_PORT))
s.listen(10)

# protocol: type B,data lenB
connection_list = []
c = Can()


# canid = 0x258, ext id, 8 bytes, padding 3 Bytes, 8 Bytes 
# 5802 0080 0800 0000 6902 0202 0200 0000 

# TCP -> CAN
class Controller(threading.Thread):
	def __init__(self, conn):
		threading.Thread.__init__(self)
		self.conn = conn
		
	def run(self):
		while True:
			type_and_len = self.conn.recv(1)
			if len(type_and_len) == 0:
				print('client disconnected')
				connection_list.remove(conn)
				break
			elif len(type_and_len) < 0:
				continue
			
			_type = type_and_len[0]
			if _type == CAN_TO_SLAVES:
				frame = self.conn.recv(16)
				print("sending frame ", Can.nice_hex(frame))
				# just send whole frame
				c.s.send(frame)


# CAN -> TCP
class CANListener(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		
	def run(self):
		while True:
			# read from CAN
			can_frame = c.s.recv(16)
			for i in connection_list:
				# send to all connected TCPs
				i.send(struct.pack('B', CAN_TO_NETWORK) + can_frame)

listener = CANListener()
listener.start()
while True:
	conn, addr = s.accept()
	print("new connection " + str(addr))
	connection_list.append(conn)
	cnt = Controller(conn)
	cnt.start()
